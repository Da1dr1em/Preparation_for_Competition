# 本仓库旨在实现一个128位AES加密系统

![image.png](https://i-blog.csdnimg.cn/blog_migrate/8e0b194c4b371c7c7740ad7d286f06a7.png)

把输入128位字符拆分成16组*8字节的矩阵，每一格8字节

以**abcdefghijklmnop**举例(ASCII编码)
![image.png](https://i-blog.csdnimg.cn/blog_migrate/de48195d6531b0895c0e5e200dc679da.png)
例如`a->96(十进制)->0x61(十六进制)`,其中**0x**表示是十六进制，$(61)_{16}$刚刚好对应八位二进制

> 类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示
> 
> — [AES加密算法原理的详细介绍与实现-CSDN博客](https://blog.csdn.net/qq_28205153/article/details/55798628#content_views:~:text=%E7%B1%BB%E4%BC%BC%E5%9C%B0%2C128%E4%BD%8D%E5%AF%86%E9%92%A5%E4%B9%9F%E6%98%AF%E7%94%A8%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%2C%E7%9F%A9%E9%98%B5%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E8%A2%AB%E7%A7%B0%E4%B8%BA1%E4%B8%AA32%E4%BD%8D%E6%AF%94%E7%89%B9%E5%AD%97%E3%80%82%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E7%BC%96%E6%8E%92%E5%87%BD%E6%95%B0%E8%AF%A5%E5%AF%86%E9%92%A5%E7%9F%A9%E9%98%B5%E8%A2%AB%E6%89%A9%E5%B1%95%E6%88%90%E4%B8%80%E4%B8%AA44%E4%B8%AA%E5%AD%97%E7%BB%84%E6%88%90%E7%9A%84%E5%BA%8F%E5%88%97w%5B0%5D%2Cw%5B1%5D%2C%20...%20%2Cw%5B43%5D%2C%E8%AF%A5%E5%BA%8F%E5%88%97%E7%9A%84%E5%89%8D4%E4%B8%AA%E5%85%83%E7%B4%A0w%5B0%5D%2Cw%5B1%5D%2Cw%5B2%5D%2Cw%5B3%5D%E6%98%AF%E5%8E%9F%E5%A7%8B%E5%AF%86%E9%92%A5%2C%E7%94%A8%E4%BA%8E%E5%8A%A0%E5%AF%86%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%AF%86%E9%92%A5%E5%8A%A0%28%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%29%3B%E5%90%8E%E9%9D%A240%E4%B8%AA%E5%AD%97%E5%88%86%E4%B8%BA10%E7%BB%84%2C%E6%AF%8F%E7%BB%844%E4%B8%AA%E5%AD%97%28128%E6%AF%94%E7%89%B9%29%E5%88%86%E5%88%AB%E7%94%A8%E4%BA%8E10%E8%BD%AE%E5%8A%A0%E5%AF%86%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E8%BD%AE%E5%AF%86%E9%92%A5%E5%8A%A0%2C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA)
![image.png](https://i-blog.csdnimg.cn/blog_migrate/5e024938d01956e9275c5c8c76482b93.png)

上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, $W[0] = K0 K1 K2 K3 = “abcd”$。

AES的整体结构如下图所示，其中的$W[0,3]$是指$W[0]$、$W[1]$、$W[2]$和$W[3]$串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。  
![aes_struct](https://i-blog.csdnimg.cn/blog_migrate/574604ab6bf5f632f275528b95a4d8a2.png)  


# 加密过程详解
## 字节代换
字节代换就是查表的过程，而AES定义了一个S盒
AES的S盒：

| 行/列 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0x63 | 0x7c | 0x77 | 0x7b | 0xf2 | 0x6b | 0x6f | 0xc5 | 0x30 | 0x01 | 0x67 | 0x2b | 0xfe | 0xd7 | 0xab | 0x76 |
| 1 | 0xca | 0x82 | 0xc9 | 0x7d | 0xfa | 0x59 | 0x47 | 0xf0 | 0xad | 0xd4 | 0xa2 | 0xaf | 0x9c | 0xa4 | 0x72 | 0xc0 |
| 2 | 0xb7 | 0xfd | 0x93 | 0x26 | 0x36 | 0x3f | 0xf7 | 0xcc | 0x34 | 0xa5 | 0xe5 | 0xf1 | 0x71 | 0xd8 | 0x31 | 0x15 |
| 3 | 0x04 | 0xc7 | 0x23 | 0xc3 | 0x18 | 0x96 | 0x05 | 0x9a | 0x07 | 0x12 | 0x80 | 0xe2 | 0xeb | 0x27 | 0xb2 | 0x75 |
| 4 | 0x09 | 0x83 | 0x2c | 0x1a | 0x1b | 0x6e | 0x5a | 0xa0 | 0x52 | 0x3b | 0xd6 | 0xb3 | 0x29 | 0xe3 | 0x2f | 0x84 |
| 5 | 0x53 | 0xd1 | 0x00 | 0xed | 0x20 | 0xfc | 0xb1 | 0x5b | 0x6a | 0xcb | 0xbe | 0x39 | 0x4a | 0x4c | 0x58 | 0xcf |
| 6 | 0xd0 | 0xef | 0xaa | 0xfb | 0x43 | 0x4d | 0x33 | 0x85 | 0x45 | 0xf9 | 0x02 | 0x7f | 0x50 | 0x3c | 0x9f | 0xa8 |
| 7 | 0x51 | 0xa3 | 0x40 | 0x8f | 0x92 | 0x9d | 0x38 | 0xf5 | 0xbc | 0xb6 | 0xda | 0x21 | 0x10 | 0xff | 0xf3 | 0xd2 |
| 8 | 0xcd | 0x0c | 0x13 | 0xec | 0x5f | 0x97 | 0x44 | 0x17 | 0xc4 | 0xa7 | 0x7e | 0x3d | 0x64 | 0x5d | 0x19 | 0x73 |
| 9 | 0x60 | 0x81 | 0x4f | 0xdc | 0x22 | 0x2a | 0x90 | 0x88 | 0x46 | 0xee | 0xb8 | 0x14 | 0xde | 0x5e | 0x0b | 0xdb |
| A | 0xe0 | 0x32 | 0x3a | 0x0a | 0x49 | 0x06 | 0x24 | 0x5c | 0xc2 | 0xd3 | 0xac | 0x62 | 0x91 | 0x95 | 0xe4 | 0x79 |
| B | 0xe7 | 0xc8 | 0x37 | 0x6d | 0x8d | 0xd5 | 0x4e | 0xa9 | 0x6c | 0x56 | 0xf4 | 0xea | 0x65 | 0x7a | 0xae | 0x08 |
| C | 0xba | 0x78 | 0x25 | 0x2e | 0x1c | 0xa6 | 0xb4 | 0xc6 | 0xe8 | 0xdd | 0x74 | 0x1f | 0x4b | 0xbd | 0x8b | 0x8a |
| D | 0x70 | 0x3e | 0xb5 | 0x66 | 0x48 | 0x03 | 0xf6 | 0x0e | 0x61 | 0x35 | 0x57 | 0xb9 | 0x86 | 0xc1 | 0x1d | 0x9e |
| E | 0xe1 | 0xf8 | 0x98 | 0x11 | 0x69 | 0xd9 | 0x8e | 0x94 | 0x9b | 0x1e | 0x87 | 0xe9 | 0xce | 0x55 | 0x28 | 0xdf |
| F | 0x8c | 0xa1 | 0x89 | 0x0d | 0xbf | 0xe6 | 0x42 | 0x68 | 0x41 | 0x99 | 0x2d | 0x0f | 0xb0 | 0x54 | 0xbb | 0x16 |

状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：  
![字节变换](https://i-blog.csdnimg.cn/blog_migrate/70ceeab2d9a5d45426ffc2970ad3a15d.png)

## 行移位
**注意AES里行列的排列方式不一样哦**

![行移位](https://i-blog.csdnimg.cn/blog_migrate/6b11cb8ddecd350f2e10d602d4d8aa54.png)

## 列混合
列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：  
![col](https://i-blog.csdnimg.cn/blog_migrate/e2c06e75355a5646c48e9e34d6b6ae8c.png)

状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：  
![col2](https://i-blog.csdnimg.cn/blog_migrate/b40d826536c020297b28c6718b2f03cf.png)

其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 = (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 \* S1如下图所示：  
![col3](https://i-blog.csdnimg.cn/blog_migrate/3d2821753c987009467ee4bc32bd5d47.png)  
也就是说，如果a7为1，则进行异或运算，否则不进行。  
类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：  
![col4](https://i-blog.csdnimg.cn/blog_migrate/59a9189060c3282ac955e94998353c9d.png)  
乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3cd9fdef1e1047d154a8c11bcfb898fa.png#pic_center)

因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。  
下面举个具体的例子,输入的状态矩阵如下：

|  |  |  |  |
| --- | --- | --- | --- |
| C9 | E5 | FD | 2B |
| 7A | F2 | 78 | 6E |
| 63 | 9C | 26 | 67 |
| B0 | A7 | 82 | E5 |

下面，进行列混合运算：  
以第一列的运算为例：  
![col7](https://i-blog.csdnimg.cn/blog_migrate/7fec49d9a2b17de95dc8c5abf8b7da2b.png)  
其它列的计算就不列举了，列混合后生成的新状态矩阵如下：

|  |  |  |  |
| --- | --- | --- | --- |
| D4 | E7 | CD | 66 |
| 28 | 02 | E5 | BB |
| BE | C6 | 54 | BF |
| 22 | 0F | 5D | A5 |


## 轮密钥加
轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字$W[4i],W[4i+1],W[4i+2],W[4i+3]$为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与$W[4i]$的异或运算。
![image](https://i-blog.csdnimg.cn/blog_migrate/60bb2a8f1d7c31bceac9d062272d3ad2.png)

### 密钥扩展
AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示
![image](https://i-blog.csdnimg.cn/blog_migrate/6a5033dcebea415390da5b2a771b8495.png)
_这个4_4矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为$W[0]、W[1]、W[2]和W[3]$，它们构成一个以字为单位的数组W。例如，设密钥K为"abcdefghijklmnop",则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,$W[0]$ = “abcd”。  
接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：  
1.如果i不是4的倍数，那么第i列由如下等式确定：  
$W[i]=W[i-4]⨁W[i-1]  $
2.如果i是4的倍数，那么第i列由如下等式确定：  
$W[i]=W[i-4]⨁T(W[i-1])$  
其中，T是一个有点复杂的函数。  
函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。  
a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字$[b0, b1, b2, b3]$变换成$[b1,b2,b3,b0]$。  
b.字节代换：对字循环的结果使用S盒进行字节代换。  
c.轮常量异或：将前两步的结果同轮常量$Rcon[j]$进行异或，其中j表示轮数。  
轮常量$Rcon[j]$是一个字，其值见下表。

| j | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- |
| $Rcon[j]$ | 01 00 00 00 | 02 00 00 00 | 04 00 00 00 | 08 00 00 00 | 10 00 00 00 |
| j | 6 | 7 | 8 | 9 | 10 |
| $Rcon[j]$ | 20 00 00 00 | 40 00 00 00 | 80 00 00 00 | 1B 00 00 00 | 36 00 00 00 |

下面举个例子：  
设初始的128位密钥为：  
3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD  
那么4个初始值为：  
W[0] = 3C A1 0B 21  
W[1] = 57 F0 19 16  
W[2] = 90 2E 13 80  
W[3] = AC C1 07 BD  
下面求扩展的第1轮的子密钥$(W[4],W[5],W[6],W[7])$。  
由于4是4的倍数，所以：  
$W[4] = W[0] ⨁ T(W[3])$  
$T(W[3])$的计算步骤如下：

1.  循环地将$W[3]$的元素移位：AC C1 07 BD变成C1 07 BD AC;
2.  将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;
3.  将78 C5 7A 91与第一轮轮常量$Rcon[1]$进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故  
    W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0  
    其余的3个子密钥段的计算如下：  
    W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6  
    W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26  
    W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B  
    所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B。